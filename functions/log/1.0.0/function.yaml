input:
  schema:
    document:
      type: object
      properties:
        message:
          type: string
          title: LogMessage
          description: The message to log.
        level:
          type: string
          enum: [ trace, debug, information, warning, error, critical ]
          default: information
          title: LogLevel
          description: The level of the message to log.
        context:
          type: string
          title: LogSourceContext
          description: The log's source context.
        arguments:
          type: object
          title: LogArguments
          description: An key/value mapping of the arguments, if any, to use to interpolate the log message.
        output:
          type: string
          title: LogOutput
          description: The path to the file to append the log message to. If not set, the log will be written to STDOUT.
        timestamp:
          type: boolean
          title: LogTimestamp
          description: Determines whether or not to timestamp the log message.
        format:
          type: string
          default: '{TIMESTAMP} [{LEVEL}] ({CONTEXT}): {MESSAGE}'
          title: LogFormat
          description: A string used to determine the format of the log to perform. The format string accepts {TIMESTAMP}, {CONTEXT}, {LEVEL} and {MESSAGE} arguments.
      required: [ message ]
output:
  schema:
    document:
      type: string
      description: The formatted log message.
run:
  script:
    language: python
    arguments:
      message: ${ .message }
      level: ${ .level }
      context: ${ .context }
      arguments: ${ .arguments }
      output: ${ .output }
      timestamp: ${ .timestamp }
      format: ${ .format }
    code: |
      import logging
      import sys
      import json
      from datetime import datetime
      import io
      
      log_levels = {
          'trace': logging.DEBUG,
          'debug': logging.DEBUG,
          'information': logging.INFO,
          'warning': logging.WARNING,
          'error': logging.ERROR,
          'critical': logging.CRITICAL
      }
      
      class ISO8601Formatter(logging.Formatter):
          def formatTime(self, record, datefmt=None):
              return datetime.fromtimestamp(record.created).astimezone().isoformat()
      
      def main():
          log_level = log_levels[level]
          
          format_string = format
          if timestamp:
              format_string = format_string.replace('{TIMESTAMP}', '%(asctime)s')
          else:
              format_string = format_string.replace('{TIMESTAMP}', '')
          if not context:
              format_string = format_string.replace(' ({CONTEXT})', '')
              
          format_string = format_string.strip(':').strip()

          log_message = message
          if arguments:
              try:
                  log_arguments = json.loads(arguments)
                  log_message = log_message.format(**log_arguments)
              except json.JSONDecodeError:
                  print("Error: Invalid JSON format for --arguments")
                  sys.exit(1)
          
          logger = logging.getLogger(context or '__main__')
          logger.setLevel(log_level)
          
          formatter = ISO8601Formatter(format_string.replace('{LEVEL}', '%(levelname)s')
                                            .replace('{CONTEXT}', '%(name)s')
                                            .replace('{MESSAGE}', '%(message)s')) \
              if timestamp else \
              logging.Formatter(format_string.replace('{LEVEL}', '%(levelname)s')
                                              .replace('{CONTEXT}', '%(name)s')
                                              .replace('{MESSAGE}', '%(message)s'))

          if output:
              handler = logging.FileHandler(output)
          else:
              handler = logging.StreamHandler(sys.stdout)
              
          handler.setLevel(log_level)
          handler.setFormatter(formatter)
          logger.addHandler(handler)
          
          log_output = io.StringIO()
          log_capture_handler = logging.StreamHandler(log_output)
          log_capture_handler.setFormatter(formatter)
          logger.addHandler(log_capture_handler)
          
          logger.log(log_level, log_message)
          
          if output:
              log_output.seek(0)
              print(log_output.getvalue().strip())
          
      if __name__ == "__main__":
          main()
